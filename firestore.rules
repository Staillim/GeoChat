/**
 * @fileOverview Firestore Security Rules for GeoChat.
 *
 * Core Philosophy:
 * This ruleset enforces a strict user-ownership model for user-specific data and a shared-access model for conversations.
 *
 * Data Structure:
 * - /users/{userId}: Stores user account information. Readable by all authenticated users (for search/map).
 * - /users/{userId}/profile: Stores user profile information, accessible only by the user.
 * - /users/{userId}/pointsOfInterest/{pointOfInterestId}: Stores points of interest associated with a user profile.
 * - /conversations/{conversationId}: Stores conversation information with status (pending/active/blocked).
 * - /conversations/{conversationId}/messages/{messageId}: Stores messages within conversations.
 * - /chatRequests/{requestId}: Stores chat/friend requests with approval workflow.
 * - /chatRooms/{chatRoomId}: Legacy chat room structure (kept for backward compatibility).
 *
 * Key Security Decisions:
 * - Users can read all user profiles (for PIN search and map display).
 * - Conversations have status control (pending until accepted).
 * - Messages can only be sent in active conversations.
 * - Chat requests implement a two-step approval process.
 *
 * Denormalization for Authorization:
 * - Messages store `senderId` for independent authorization.
 * - Chat requests store user info to avoid extra reads.
 * - Conversations store `createdBy` and `status` for access control.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Controls access to user account documents.
     * @path /users/{userId}
     * @allow (create) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can create their account if request.auth.uid == userId.
     * @allow (get) Any authenticated user can read any user profile (for map display).
     * @allow (list) Any authenticated user can list users (for map display).
     * @allow (update) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can update their account.
     * @allow (delete) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can delete their account.
     * @deny (create) User 'attackerId' cannot create an account with userId 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1'.
     * @principle Enforces document ownership for writes, but allows authenticated users to read for map functionality.
     */
    match /users/{userId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId));
      }

      allow get: if isSignedIn(); // Allow any authenticated user to read user profiles
      allow list: if isSignedIn(); // Allow any authenticated user to list users for map
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to user profile documents.
     * @path /users/{userId}/profile
     * @allow (create) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can create their profile.
     * @allow (get) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can read their profile.
     * @allow (update) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can update their profile.
     * @allow (delete) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can delete their profile.
     * @deny (create) User 'attackerId' cannot create a profile for userId 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1'.
     * @principle Restricts access to a user's own data tree.
     */
    match /users/{userId}/profile {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId)/profile);
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to points of interest associated with a user profile.
     * @path /users/{userId}/pointsOfInterest/{pointOfInterestId}
     * @allow (create) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can create a point of interest.
     * @allow (get) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can read their points of interest.
     * @allow (update) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can update their points of interest.
     * @allow (delete) User 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1' can delete their points of interest.
     * @deny (create) User 'attackerId' cannot create a point of interest for userId 'hnG1KG4hnQgTfs6KpCX4JGxiZZl1'.
     * @principle Restricts access to a user's own data.
     */
    match /users/{userId}/pointsOfInterest/{pointOfInterestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isOwner(userId) {
        return request.auth.uid == userId;
      }

      function isExistingOwner(userId) {
        return isOwner(userId) && exists(/databases/$(database)/documents/users/$(userId)/pointsOfInterest/$(pointOfInterestId));
      }

      allow get: if isOwner(userId);
      allow list: if false;
      allow create: if isSignedIn() && isOwner(userId);
      allow update: if isExistingOwner(userId);
      allow delete: if isExistingOwner(userId);
    }

    /**
     * @description Controls access to chat room documents.
     * @path /chatRooms/{chatRoomId}
     * @allow (create) Any signed-in user can create a chat room. Ensure participant list includes the creator.
     * @allow (get) Any participant can read the chat room.
     * @allow (update) Only participants can update. Updating `participantIds` requires special permission (TODO).
     * @allow (delete) Only participants can delete.
     * @deny (create) Anonymous user can not create a chat room.
     * @deny (create) User 'attackerId' cannot create a chat room without including themself in participantIds.
     * @principle Enforces shared access between collaborators.
     */
    match /chatRooms/{chatRoomId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(chatRoomId) {
        return isSignedIn() && request.auth.uid in resource.data.participantIds;
      }

        // Checks if the requesting user is in the chatRoom's participant list.
      function isParticipantList(chatRoomId) {
        return isSignedIn() && request.auth.uid in request.resource.data.participantIds;
      }

      function isExistingParticipant(chatRoomId) {
        return isSignedIn() && request.auth.uid in resource.data.participantIds;
      }
      
      allow get: if isParticipant(chatRoomId);
      allow list: if true; //Public listing of chatrooms, should be limited if sensitive information is involved
      allow create: if isSignedIn() && (request.resource.data.participantIds.size() > 0) && (request.auth.uid in request.resource.data.participantIds) ;
      allow update: if isExistingParticipant(chatRoomId);
      allow delete: if isExistingParticipant(chatRoomId);
    }

    /**
     * @description Controls access to chat messages within a chat room.
     * @path /chatRooms/{chatRoomId}/messages/{messageId}
     * @allow (create) Any participant can create a message.
     * @allow (get) Any participant can read a message.
     * @allow (update) No one can update a message.
     * @allow (delete) No one can delete a message.
     * @deny (create) User 'attackerId' cannot create a message in a chat room they don't belong to.
     * @principle Enforces shared access between collaborators.
     */
    match /chatRooms/{chatRoomId}/messages/{messageId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant(chatRoomId) {
          return isSignedIn() && request.auth.uid in get(/databases/$(database)/documents/chatRooms/$(chatRoomId)).data.participantIds;
      }

      function isExistingParticipant(chatRoomId) {
        return isParticipant(chatRoomId);
      }

      allow get: if isParticipant(chatRoomId);
      allow list: if isParticipant(chatRoomId);
      allow create: if isParticipant(chatRoomId) && request.resource.data.senderId == request.auth.uid;
      allow update: if false;
      allow delete: if false;
    }

    /**
     * @description Controls access to conversation documents (chat structure with status control).
     * @path /conversations/{conversationId}
     * @allow (create) Any signed-in user can create a conversation with status 'pending' or 'active'.
     * @allow (get) Any participant can read the conversation.
     * @allow (list) Any signed-in user can list conversations they're part of (filtered by query).
     * @allow (update) Participants can update. Creator can update lastMessage. Recipient can accept (change status).
     * @allow (delete) Only participants can delete.
     * @principle Enforces shared access with status-based approval workflow.
     */
    match /conversations/{conversationId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isParticipant() {
        return isSignedIn() && request.auth.uid in resource.data.participants;
      }

      function isParticipantInNew() {
        return isSignedIn() && request.auth.uid in request.resource.data.participants;
      }

      function isCreator() {
        return isSignedIn() && request.auth.uid == resource.data.createdBy;
      }

      function isValidStatus() {
        return request.resource.data.status in ['pending', 'active', 'blocked'];
      }

      function isAcceptingRequest() {
        return resource.data.status == 'pending' 
               && request.resource.data.status == 'active'
               && !isCreator();
      }

      function isUpdatingActiveConversation() {
        return isCreator() && resource.data.status == 'active';
      }

      // Any participant can read the conversation
      allow get: if isParticipant();
      
      // Users can list their conversations (query filters by participants array)
      allow list: if isSignedIn();
      
      // Create: must be participant, set valid status, and set createdBy
      allow create: if isSignedIn() 
                    && isParticipantInNew() 
                    && isValidStatus()
                    && request.resource.data.createdBy == request.auth.uid
                    && request.resource.data.participants.size() == 2;
      
      // Update: creator can update if active, or recipient can accept pending
      allow update: if isParticipant() 
                    && (isUpdatingActiveConversation() || isAcceptingRequest());
      
      // Delete: any participant can delete
      allow delete: if isParticipant();

      /**
       * @description Controls access to messages within a conversation.
       * @path /conversations/{conversationId}/messages/{messageId}
       * @allow (create) Participants can create messages only in active conversations.
       * @allow (get) Any participant can read a message.
       * @allow (list) Any participant can list messages.
       * @allow (update) No one can update messages (immutable).
       * @allow (delete) No one can delete messages (immutable).
       * @principle Messages are immutable and require active conversation status.
       */
      match /messages/{messageId} {
        function isConversationParticipant() {
          return isSignedIn() 
                 && request.auth.uid in get(/databases/$(database)/documents/conversations/$(conversationId)).data.participants;
        }

        function isConversationActive() {
          return get(/databases/$(database)/documents/conversations/$(conversationId)).data.status == 'active';
        }

        allow get: if isConversationParticipant();
        allow list: if isConversationParticipant();
        
        // Only create messages if conversation is active
        allow create: if isConversationParticipant() 
                      && isConversationActive()
                      && request.resource.data.senderId == request.auth.uid;
        
        allow update: if false; // Messages are immutable
        allow delete: if false; // Messages are immutable
      }
    }

    /**
     * @description Controls access to chat/friend request documents.
     * @path /chatRequests/{requestId}
     * @allow (create) Sender can create requests with status 'pending'.
     * @allow (get) Sender or recipient can read the request.
     * @allow (list) Users can list requests where they are sender or recipient (filtered by query).
     * @allow (update) Only recipient can update to accept/reject pending requests.
     * @allow (delete) Only sender can delete their own pending requests.
     * @principle Implements approval workflow for chat requests.
     */
    match /chatRequests/{requestId} {
      function isSignedIn() {
        return request.auth != null;
      }

      function isSender() {
        return isSignedIn() && request.auth.uid == resource.data.fromUserId;
      }

      function isRecipient() {
        return isSignedIn() && request.auth.uid == resource.data.toUserId;
      }

      function isValidNewRequest() {
        return request.resource.data.fromUserId == request.auth.uid
               && request.resource.data.status == 'pending'
               && request.resource.data.keys().hasAll(['fromUserId', 'toUserId', 'conversationId', 'status', 'createdAt']);
      }

      function isValidStatusChange() {
        return resource.data.status == 'pending'
               && request.resource.data.status in ['accepted', 'rejected']
               && isRecipient();
      }

      // Read: sender or recipient can read
      allow get: if isSender() || isRecipient();
      
      // List: users can list their requests (query must filter by fromUserId or toUserId)
      allow list: if isSignedIn();
      
      // Create: only sender can create with status 'pending'
      allow create: if isSignedIn() && isValidNewRequest();
      
      // Update: only recipient can accept/reject pending requests
      allow update: if isValidStatusChange();
      
      // Delete: only sender can delete their own pending requests
      allow delete: if isSender() && resource.data.status == 'pending';
    }
  }
}